import type { Box } from "@/types/box";
import type {
  AsciiOutput,
  AsciiGenerationOptions,
  AsciiGrid,
} from "../types/ascii";
import { ASCII_CONSTANTS } from "@/lib/constants";
import {
  createGrid,
  gridToString,
  countCharacters,
  countLines,
  validateGridSize,
} from "./characterGrid";
import {
  calculateGridDimensions,
  getBoxCharBounds,
  getBoxContentBounds,
  meetsMinimumCharDimensions,
} from "./coordinateMapper";
import { renderBoxBorder } from "./boxRenderer";
import { resolveAllJunctions } from "./junctionResolver";
import { renderTextContent } from "./textRenderer";

export function generateAscii(
  boxes: Box[],
  options?: AsciiGenerationOptions
): AsciiOutput {
  const startTime = Date.now();

  const charWidthRatio =
    options?.charWidthRatio ?? ASCII_CONSTANTS.CHAR_WIDTH_RATIO;
  const charHeightRatio =
    options?.charHeightRatio ?? ASCII_CONSTANTS.CHAR_HEIGHT_RATIO;
  const includeMetadata = options?.includeMetadata ?? false;

  const warnings: string[] = [];

  if (boxes.length === 0) {
    return {
      content: "// Empty canvas - create some boxes to see ASCII output!",
      characterCount: 0,
      lineCount: 1,
      dimensions: { width: 0, height: 0 },
      boxCount: 0,
      warnings: ["No boxes to render"],
      timestamp: new Date(),
    };
  }

  const gridDims = calculateGridDimensions(
    boxes,
    charWidthRatio,
    charHeightRatio
  );

  const grid: AsciiGrid = createGrid(gridDims.width, gridDims.height);

  for (const box of boxes) {
    if (
      !meetsMinimumCharDimensions(box, boxes, charWidthRatio, charHeightRatio)
    ) {
      warnings.push(
        `Box "${box.id}" is too small to render properly (min ${ASCII_CONSTANTS.MIN_BOX_CHARS_WIDTH}x${ASCII_CONSTANTS.MIN_BOX_CHARS_HEIGHT} characters)`
      );
    }
  }

  const sortedBoxes = [...boxes].sort((a, b) => a.zIndex - b.zIndex);

  for (const box of sortedBoxes) {
    renderBox(
      grid,
      box,
      boxes,
      charWidthRatio,
      charHeightRatio,
      gridDims.offsetCol,
      gridDims.offsetRow
    );
  }

  resolveAllJunctions(grid);

  const validation = validateGridSize(grid);
  if (!validation.valid) {
    warnings.push(...validation.warnings);
  }

  let content = gridToString(grid);

  if (includeMetadata) {
    const metadata = [
      `<!-- Generated by ASCII Layout Builder -->`,
      `<!-- Boxes: ${boxes.length} -->`,
      `<!-- Dimensions: ${gridDims.width}x${gridDims.height} -->`,
      `<!-- Generated: ${new Date().toISOString()} -->`,
      "",
    ].join("\n");
    content = metadata + content;
  }

  return {
    content,
    characterCount: countCharacters(grid),
    lineCount: countLines(grid),
    dimensions: {
      width: gridDims.width,
      height: gridDims.height,
    },
    boxCount: boxes.length,
    warnings,
    timestamp: new Date(startTime),
  };
}

function renderBox(
  grid: AsciiGrid,
  box: Box,
  allBoxes: Box[],
  charWidthRatio: number,
  charHeightRatio: number,
  offsetCol: number,
  offsetRow: number
): void {
  const absoluteBounds = getBoxCharBounds(
    box,
    allBoxes,
    charWidthRatio,
    charHeightRatio
  );

  const normalizedBounds = {
    startCol: absoluteBounds.startCol - offsetCol,
    startRow: absoluteBounds.startRow - offsetRow,
    endCol: absoluteBounds.endCol - offsetCol,
    endRow: absoluteBounds.endRow - offsetRow,
    width: absoluteBounds.width,
    height: absoluteBounds.height,
  };

  renderBoxBorder(grid, box, normalizedBounds);

  const absoluteContentBounds = getBoxContentBounds(
    box,
    allBoxes,
    charWidthRatio,
    charHeightRatio
  );

  const normalizedContentBounds = {
    startCol: absoluteContentBounds.startCol - offsetCol,
    startRow: absoluteContentBounds.startRow - offsetRow,
    endCol: absoluteContentBounds.endCol - offsetCol,
    endRow: absoluteContentBounds.endRow - offsetRow,
    width: absoluteContentBounds.width,
    height: absoluteContentBounds.height,
  };

  if (box.text && box.text.value.trim() !== "") {
    renderTextContent(grid, box, normalizedContentBounds);
  }
}

export function generateAsciiForBoxes(
  boxes: Box[],
  options?: AsciiGenerationOptions
): AsciiOutput {
  return generateAscii(boxes, options);
}

export function generateAsciiWithScale(
  boxes: Box[],
  scale: "compact" | "normal" | "spacious"
): AsciiOutput {
  const ratios = {
    compact: { width: 1.5, height: 2.5 },
    normal: { width: 2, height: 3 },
    spacious: { width: 3, height: 4 },
  };

  const { width, height } = ratios[scale];

  return generateAscii(boxes, {
    charWidthRatio: width,
    charHeightRatio: height,
  });
}

export function canGenerateAscii(boxes: Box[]): {
  canGenerate: boolean;
  reason?: string;
} {
  if (boxes.length === 0) {
    return { canGenerate: false, reason: "No boxes to render" };
  }

  const dims = calculateGridDimensions(boxes);

  if (dims.width > ASCII_CONSTANTS.MAX_LINE_LENGTH) {
    return {
      canGenerate: false,
      reason: `Canvas too wide (${dims.width} > ${ASCII_CONSTANTS.MAX_LINE_LENGTH} chars)`,
    };
  }

  if (dims.height > ASCII_CONSTANTS.MAX_OUTPUT_LINES) {
    return {
      canGenerate: false,
      reason: `Canvas too tall (${dims.height} > ${ASCII_CONSTANTS.MAX_OUTPUT_LINES} lines)`,
    };
  }

  return { canGenerate: true };
}
