import type { Box } from "@/types/box";
import type { Line } from "@/types/line";
import type { Artboard } from "@/types/artboard";
import type {
  AsciiOutput,
  AsciiGenerationOptions,
  AsciiGrid,
} from "../types/ascii";
import { ASCII_CONSTANTS } from "@/lib/constants";
import { getBoxesInArtboard } from "@/features/artboards/utils/artboardHelpers";
import {
  createGrid,
  gridToString,
  countCharacters,
  countLines,
  validateGridSize,
} from "./characterGrid";
import {
  calculateGridDimensions,
  getBoxCharBounds,
  getBoxContentBounds,
  meetsMinimumCharDimensions,
} from "./coordinateMapper";
import { renderBoxBorder } from "./boxRenderer";
import { resolveAllJunctions } from "./junctionResolver";
import { renderTextContent } from "./textRenderer";
import { renderAllLines } from "./lineRenderer";

export function generateAscii(
  boxes: Box[],
  options?: AsciiGenerationOptions,
  artboard?: Artboard,
  lines: Line[] = []
): AsciiOutput {
  const startTime = Date.now();

  const charWidthRatio =
    options?.charWidthRatio ?? ASCII_CONSTANTS.CHAR_WIDTH_RATIO;
  const charHeightRatio =
    options?.charHeightRatio ?? ASCII_CONSTANTS.CHAR_HEIGHT_RATIO;
  const includeMetadata = options?.includeMetadata ?? false;

  const warnings: string[] = [];

  let boxesToRender = boxes;
  let linesToRender = lines.filter(
    (line) => line.outputMode === "ascii" && line.visible !== false
  );

  if (artboard) {
    boxesToRender = getBoxesInArtboard(artboard.id, boxes);

    boxesToRender = boxesToRender.map((box) => ({
      ...box,
      x: box.x - artboard.x,
      y: box.y - artboard.y,
    }));

    linesToRender = linesToRender
      .filter((line) => line.artboardId === artboard.id)
      .map((line) => ({
        ...line,
        startX: line.startX - artboard.x,
        startY: line.startY - artboard.y,
        endX: line.endX - artboard.x,
        endY: line.endY - artboard.y,
      }));
  }

  if (boxesToRender.length === 0 && linesToRender.length === 0) {
    const emptyMessage = artboard
      ? `// Artboard "${artboard.name}" is empty - drag boxes or draw lines here to see ASCII output!`
      : "// Empty canvas - create some boxes or lines to see ASCII output!";

    return {
      content: emptyMessage,
      characterCount: 0,
      lineCount: 1,
      dimensions: { width: 0, height: 0 },
      boxCount: 0,
      warnings: artboard
        ? [`Artboard "${artboard.name}" has no content`]
        : ["No content to render"],
      timestamp: new Date(),
    };
  }

  const gridDims = calculateGridDimensions(
    boxesToRender,
    charWidthRatio,
    charHeightRatio
  );

  const grid: AsciiGrid = createGrid(gridDims.width, gridDims.height);

  for (const box of boxesToRender) {
    if (
      !meetsMinimumCharDimensions(
        box,
        boxesToRender,
        charWidthRatio,
        charHeightRatio
      )
    ) {
      warnings.push(
        `Box "${box.id}" is too small to render properly (min ${ASCII_CONSTANTS.MIN_BOX_CHARS_WIDTH}x${ASCII_CONSTANTS.MIN_BOX_CHARS_HEIGHT} characters)`
      );
    }
  }

  const sortedBoxes = [...boxesToRender].sort((a, b) => a.zIndex - b.zIndex);

  for (const box of sortedBoxes) {
    renderBox(
      grid,
      box,
      boxesToRender,
      charWidthRatio,
      charHeightRatio,
      gridDims.offsetCol,
      gridDims.offsetRow
    );
  }

  if (linesToRender.length > 0) {
    renderAllLines(
      grid,
      linesToRender,
      charWidthRatio,
      charHeightRatio,
      gridDims.offsetCol,
      gridDims.offsetRow
    );
  }

  resolveAllJunctions(grid);

  const validation = validateGridSize(grid);
  if (!validation.valid) {
    warnings.push(...validation.warnings);
  }

  let content = gridToString(grid);

  if (includeMetadata) {
    const metadataLines = [`<!-- Generated by ASCII Layout Builder -->`];

    if (artboard) {
      metadataLines.push(
        `<!-- Artboard: ${artboard.name} (${artboard.width}×${artboard.height}) -->`,
        `<!-- Boxes: ${boxesToRender.length} -->`
      );
    } else {
      metadataLines.push(`<!-- Boxes: ${boxesToRender.length} -->`);
    }

    metadataLines.push(
      `<!-- Dimensions: ${gridDims.width}x${gridDims.height} -->`,
      `<!-- Generated: ${new Date().toISOString()} -->`,
      ""
    );

    const metadata = metadataLines.join("\n");
    content = metadata + content;
  }

  return {
    content,
    characterCount: countCharacters(grid),
    lineCount: countLines(grid),
    dimensions: {
      width: gridDims.width,
      height: gridDims.height,
    },
    boxCount: boxesToRender.length,
    warnings,
    timestamp: new Date(startTime),
  };
}

function renderBox(
  grid: AsciiGrid,
  box: Box,
  allBoxes: Box[],
  charWidthRatio: number,
  charHeightRatio: number,
  offsetCol: number,
  offsetRow: number
): void {
  const absoluteBounds = getBoxCharBounds(
    box,
    allBoxes,
    charWidthRatio,
    charHeightRatio
  );

  const normalizedBounds = {
    startCol: absoluteBounds.startCol - offsetCol,
    startRow: absoluteBounds.startRow - offsetRow,
    endCol: absoluteBounds.endCol - offsetCol,
    endRow: absoluteBounds.endRow - offsetRow,
    width: absoluteBounds.width,
    height: absoluteBounds.height,
  };

  renderBoxBorder(grid, box, normalizedBounds);

  const absoluteContentBounds = getBoxContentBounds(
    box,
    allBoxes,
    charWidthRatio,
    charHeightRatio
  );

  const normalizedContentBounds = {
    startCol: absoluteContentBounds.startCol - offsetCol,
    startRow: absoluteContentBounds.startRow - offsetRow,
    endCol: absoluteContentBounds.endCol - offsetCol,
    endRow: absoluteContentBounds.endRow - offsetRow,
    width: absoluteContentBounds.width,
    height: absoluteContentBounds.height,
  };

  if (box.text && box.text.value.trim() !== "") {
    renderTextContent(grid, box, normalizedContentBounds);
  }
}

export function generateAsciiForBoxes(
  boxes: Box[],
  options?: AsciiGenerationOptions,
  lines: Line[] = []
): AsciiOutput {
  return generateAscii(boxes, options, undefined, lines);
}

export function generateAsciiWithScale(
  boxes: Box[],
  scale: "compact" | "normal" | "spacious",
  lines: Line[] = []
): AsciiOutput {
  const ratios = {
    compact: { width: 1.5, height: 2.5 },
    normal: { width: 2, height: 3 },
    spacious: { width: 3, height: 4 },
  };

  const { width, height } = ratios[scale];

  return generateAscii(
    boxes,
    {
      charWidthRatio: width,
      charHeightRatio: height,
    },
    undefined,
    lines
  );
}

export function canGenerateAscii(boxes: Box[]): {
  canGenerate: boolean;
  reason?: string;
} {
  if (boxes.length === 0) {
    return { canGenerate: false, reason: "No boxes to render" };
  }

  const dims = calculateGridDimensions(boxes);

  if (dims.width > ASCII_CONSTANTS.MAX_LINE_LENGTH) {
    return {
      canGenerate: false,
      reason: `Canvas too wide (${dims.width} > ${ASCII_CONSTANTS.MAX_LINE_LENGTH} chars)`,
    };
  }

  if (dims.height > ASCII_CONSTANTS.MAX_OUTPUT_LINES) {
    return {
      canGenerate: false,
      reason: `Canvas too tall (${dims.height} > ${ASCII_CONSTANTS.MAX_OUTPUT_LINES} lines)`,
    };
  }

  return { canGenerate: true };
}

export function generateAsciiForArtboard(
  artboard: Artboard,
  boxes: Box[],
  options?: AsciiGenerationOptions,
  lines: Line[] = []
): AsciiOutput {
  return generateAscii(boxes, options, artboard, lines);
}

export function generateAllArtboards(
  artboards: Artboard[],
  boxes: Box[],
  options?: AsciiGenerationOptions,
  lines: Line[] = []
): Map<string, AsciiOutput> {
  const results = new Map<string, AsciiOutput>();

  const sortedArtboards = [...artboards].sort((a, b) =>
    a.name.localeCompare(b.name)
  );

  for (const artboard of sortedArtboards) {
    if (artboard.visible) {
      const output = generateAsciiForArtboard(artboard, boxes, options, lines);
      results.set(artboard.id, output);
    }
  }

  return results;
}

export function formatMultipleArtboards(
  artboardOutputs: Map<string, AsciiOutput>,
  artboards: Artboard[]
): string {
  const artboardMap = new Map(artboards.map((a) => [a.id, a]));
  const sections: string[] = [];

  for (const [artboardId, output] of artboardOutputs) {
    const artboard = artboardMap.get(artboardId);
    if (!artboard) continue;

    const header = [
      "",
      "=".repeat(60),
      `  ${artboard.name} (${artboard.width}×${artboard.height})`,
      "=".repeat(60),
      "",
    ].join("\n");

    sections.push(header + output.content);
  }

  return sections.join("\n\n");
}
