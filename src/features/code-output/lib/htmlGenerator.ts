import type { Box } from "@/types/box";
import type { Artboard } from "@/types/artboard";
import type { BoxCodeInfo, CodeGeneratorOptions } from "../types/code";
import { DEFAULT_CODE_OPTIONS } from "../types/code";

export function generateHTML(
  boxes: Box[],
  artboard?: Artboard,
  options: CodeGeneratorOptions = DEFAULT_CODE_OPTIONS
): string {
  const opts = { ...DEFAULT_CODE_OPTIONS, ...options };
  const { includeComments } = opts;

  const rootBoxes = boxes
    .filter((box) => !box.parentId)
    .filter((box) => (artboard ? box.artboardId === artboard.id : true))
    .sort((a, b) => a.zIndex - b.zIndex);

  if (rootBoxes.length === 0) {
    return "";
  }

  const lines: string[] = [];

  if (includeComments) {
    lines.push("<!-- Generated by ASCII Layout Builder -->");
    if (artboard) {
      lines.push(
        `<!-- Artboard: ${artboard.name} (${artboard.width}x${artboard.height}) -->`
      );
    }
  }

  if (artboard) {
    lines.push(`<div class="container">`);
    rootBoxes.forEach((box) => {
      lines.push(generateBoxHTML(box, boxes, opts, 1));
    });
    lines.push(`</div>`);
  } else {
    rootBoxes.forEach((box) => {
      lines.push(generateBoxHTML(box, boxes, opts, 0));
    });
  }

  return lines.join("\n");
}

function generateBoxHTML(
  box: Box,
  allBoxes: Box[],
  options: CodeGeneratorOptions,
  depth: number
): string {
  const { indent, classPrefix, includeComments } = options;
  const indentStr = indent!.repeat(depth);

  const className = getBoxClassName(box, classPrefix!);
  const hasText = box.text.value.trim() !== "";

  const children = allBoxes
    .filter((b) => b.parentId === box.id)
    .sort((a, b) => a.zIndex - b.zIndex);

  const lines: string[] = [];

  if (includeComments && box.name) {
    lines.push(`${indentStr}<!-- ${box.name} -->`);
  }

  const attrs = [`class="${className}"`];
  lines.push(`${indentStr}<div ${attrs.join(" ")}>`);

  if (hasText) {
    const textLines = box.text.value.split("\n");
    textLines.forEach((line) => {
      if (line.trim()) {
        lines.push(`${indentStr}${indent}${escapeHTML(line)}`);
      }
    });
  }

  children.forEach((child) => {
    lines.push(generateBoxHTML(child, allBoxes, options, depth + 1));
  });

  lines.push(`${indentStr}</div>`);

  return lines.join("\n");
}

function getBoxClassName(box: Box, prefix: string): string {
  if (box.name) {
    return box.name
      .toLowerCase()
      .replace(/[^a-z0-9]+/g, "-")
      .replace(/^-|-$/g, "");
  }

  const shortId = box.id.split("-")[0];
  return `${prefix}-${shortId}`;
}

function escapeHTML(str: string): string {
  return str
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;")
    .replace(/"/g, "&quot;")
    .replace(/'/g, "&#039;");
}

export function buildBoxCodeInfo(
  box: Box,
  allBoxes: Box[],
  classPrefix: string = "box"
): BoxCodeInfo {
  const children = allBoxes
    .filter((b) => b.parentId === box.id)
    .sort((a, b) => a.zIndex - b.zIndex);

  const className = getBoxClassName(box, classPrefix);

  return {
    id: box.id,
    name: box.name || className,
    selector: `.${className}`,
    className,
    styles: {},
    tailwindClasses: [],
    content: box.text.value,
    children: children.map((child) =>
      buildBoxCodeInfo(child, allBoxes, classPrefix)
    ),
  };
}

export function generateHTMLStructure(
  boxes: Box[],
  artboard?: Artboard
): string {
  return generateHTML(boxes, artboard, {
    ...DEFAULT_CODE_OPTIONS,
    includeComments: false,
  });
}
