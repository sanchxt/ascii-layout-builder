import type { Box, TextFormat } from "@/types/box";
import type { Line } from "@/types/line";
import type { Artboard } from "@/types/artboard";
import type { BoxCodeInfo, CodeGeneratorOptions } from "../types/code";
import { DEFAULT_CODE_OPTIONS } from "../types/code";
import { generateLineCode } from "./lineCodeGenerator";

/**
 * Formats text with semantic HTML tags based on formatting array
 * Handles bold, italic, code, and color formatting
 */
function formatTextWithSemanticTags(
  text: string,
  formatting: TextFormat[]
): string {
  if (!formatting || formatting.length === 0) {
    return escapeHTML(text);
  }

  // Create events for each formatting range
  interface FormatEvent {
    position: number;
    type: "open" | "close";
    format: TextFormat;
  }

  const events: FormatEvent[] = [];

  formatting.forEach((fmt) => {
    events.push({ position: fmt.start, type: "open", format: fmt });
    events.push({ position: fmt.end, type: "close", format: fmt });
  });

  // Sort events: by position, then closes before opens at same position
  events.sort((a, b) => {
    if (a.position !== b.position) return a.position - b.position;
    // Closes come before opens at the same position
    if (a.type === "close" && b.type === "open") return -1;
    if (a.type === "open" && b.type === "close") return 1;
    return 0;
  });

  let result = "";
  let lastPosition = 0;

  // Track open tags to properly nest them
  const openTags: TextFormat[] = [];

  events.forEach((event) => {
    // Add text before this event
    if (event.position > lastPosition) {
      result += escapeHTML(text.slice(lastPosition, event.position));
    }
    lastPosition = event.position;

    if (event.type === "open") {
      result += getOpenTag(event.format);
      openTags.push(event.format);
    } else {
      // Close tags in reverse order to maintain proper nesting
      const tagIndex = openTags.findIndex(
        (t) =>
          t.start === event.format.start &&
          t.end === event.format.end &&
          t.type === event.format.type
      );
      if (tagIndex !== -1) {
        // Close all tags after this one, then close this one, then reopen the others
        const tagsToReopen = openTags.slice(tagIndex + 1);

        // Close tags in reverse order
        for (let i = openTags.length - 1; i >= tagIndex; i--) {
          result += getCloseTag(openTags[i]);
        }

        // Remove the closed tag
        openTags.splice(tagIndex, 1);

        // Reopen the tags that were after it
        tagsToReopen.forEach((t) => {
          result += getOpenTag(t);
        });
      }
    }
  });

  // Add remaining text
  if (lastPosition < text.length) {
    result += escapeHTML(text.slice(lastPosition));
  }

  return result;
}

function getOpenTag(format: TextFormat): string {
  switch (format.type) {
    case "bold":
      return "<strong>";
    case "italic":
      return "<em>";
    case "code":
      return "<code>";
    case "color":
      return `<span style="color: ${format.value || "inherit"}">`;
    default:
      return "";
  }
}

function getCloseTag(format: TextFormat): string {
  switch (format.type) {
    case "bold":
      return "</strong>";
    case "italic":
      return "</em>";
    case "code":
      return "</code>";
    case "color":
      return "</span>";
    default:
      return "";
  }
}

export function generateHTML(
  boxes: Box[],
  artboard?: Artboard,
  options: CodeGeneratorOptions = DEFAULT_CODE_OPTIONS,
  lineElements: Line[] = []
): string {
  const opts = { ...DEFAULT_CODE_OPTIONS, ...options };
  const { includeComments } = opts;

  const rootBoxes = boxes
    .filter((box) => !box.parentId)
    .filter((box) => (artboard ? box.artboardId === artboard.id : true))
    .sort((a, b) => a.zIndex - b.zIndex);

  const lineCode = generateLineCode(lineElements, artboard, opts, boxes);

  if (rootBoxes.length === 0 && !lineCode) {
    return "";
  }

  const lines: string[] = [];

  if (includeComments) {
    lines.push("<!-- Generated by ASCII Layout Builder -->");
    if (artboard) {
      lines.push(
        `<!-- Artboard: ${artboard.name} (${artboard.width}x${artboard.height}) -->`
      );
    }
  }

  if (artboard) {
    lines.push(`<div class="container">`);
    rootBoxes.forEach((box) => {
      lines.push(generateBoxHTML(box, boxes, opts, 1));
    });

    if (lineCode) {
      lines.push(lineCode);
    }

    lines.push(`</div>`);
  } else {
    rootBoxes.forEach((box) => {
      lines.push(generateBoxHTML(box, boxes, opts, 0));
    });

    if (lineCode) {
      lines.push(lineCode);
    }
  }

  return lines.join("\n");
}

function generateBoxHTML(
  box: Box,
  allBoxes: Box[],
  options: CodeGeneratorOptions,
  depth: number
): string {
  const { indent, classPrefix, includeComments } = options;
  const indentStr = indent!.repeat(depth);

  const className = getBoxClassName(box, classPrefix!);
  const hasText = box.text.value.trim() !== "";

  const children = allBoxes
    .filter((b) => b.parentId === box.id)
    .sort((a, b) => a.zIndex - b.zIndex);

  const lines: string[] = [];

  if (includeComments && box.name) {
    lines.push(`${indentStr}<!-- ${box.name} -->`);
  }

  const attrs = [`class="${className}"`];
  lines.push(`${indentStr}<div ${attrs.join(" ")}>`);

  if (hasText) {
    const formattedText = formatTextWithSemanticTags(
      box.text.value,
      box.text.formatting || []
    );
    const textLines = formattedText.split("\n");
    textLines.forEach((line) => {
      if (line.trim()) {
        lines.push(`${indentStr}${indent}${line}`);
      }
    });
  }

  children.forEach((child) => {
    lines.push(generateBoxHTML(child, allBoxes, options, depth + 1));
  });

  lines.push(`${indentStr}</div>`);

  return lines.join("\n");
}

function getBoxClassName(box: Box, prefix: string): string {
  if (box.name) {
    return box.name
      .toLowerCase()
      .replace(/[^a-z0-9]+/g, "-")
      .replace(/^-|-$/g, "");
  }

  const shortId = box.id.split("-")[0];
  return `${prefix}-${shortId}`;
}

function escapeHTML(str: string): string {
  return str
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;")
    .replace(/"/g, "&quot;")
    .replace(/'/g, "&#039;");
}

export function buildBoxCodeInfo(
  box: Box,
  allBoxes: Box[],
  classPrefix: string = "box"
): BoxCodeInfo {
  const children = allBoxes
    .filter((b) => b.parentId === box.id)
    .sort((a, b) => a.zIndex - b.zIndex);

  const className = getBoxClassName(box, classPrefix);

  return {
    id: box.id,
    name: box.name || className,
    selector: `.${className}`,
    className,
    styles: {},
    tailwindClasses: [],
    content: box.text.value,
    children: children.map((child) =>
      buildBoxCodeInfo(child, allBoxes, classPrefix)
    ),
  };
}

export function generateHTMLStructure(
  boxes: Box[],
  artboard?: Artboard
): string {
  return generateHTML(boxes, artboard, {
    ...DEFAULT_CODE_OPTIONS,
    includeComments: false,
  });
}
