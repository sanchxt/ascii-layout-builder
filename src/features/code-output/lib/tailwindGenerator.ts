import type { Box, TextFormat } from "@/types/box";
import type { Line } from "@/types/line";
import type { Artboard } from "@/types/artboard";
import type { CodeGeneratorOptions } from "../types/code";
import {
  DEFAULT_CODE_OPTIONS,
  TAILWIND_MAPPINGS,
  getClosestTailwindSpacing,
} from "../types/code";
import { generateLineCode } from "./lineCodeGenerator";

export function generateTailwind(
  boxes: Box[],
  artboard?: Artboard,
  options: CodeGeneratorOptions = DEFAULT_CODE_OPTIONS,
  lines: Line[] = []
): string {
  const opts = { ...DEFAULT_CODE_OPTIONS, ...options };
  const { includeComments } = opts;

  const relevantBoxes = artboard
    ? boxes.filter((box) => box.artboardId === artboard.id)
    : boxes.filter((box) => !box.artboardId);

  const rootBoxes = relevantBoxes
    .filter((box) => !box.parentId)
    .sort((a, b) => a.zIndex - b.zIndex);

  const lineCode = generateLineCode(lines, artboard, opts, boxes);

  if (rootBoxes.length === 0 && !lineCode) {
    return "";
  }

  const output: string[] = [];

  if (includeComments) {
    output.push("<!-- Generated by ASCII Layout Builder with Tailwind CSS -->");
  }

  if (artboard) {
    const containerClasses = getContainerClasses(artboard);
    output.push(`<div class="${containerClasses}">`);

    rootBoxes.forEach((box) => {
      output.push(generateBoxTailwind(box, relevantBoxes, opts, 1));
    });

    if (lineCode) {
      output.push(lineCode);
    }

    output.push(`</div>`);
  } else {
    rootBoxes.forEach((box) => {
      output.push(generateBoxTailwind(box, relevantBoxes, opts, 0));
    });

    if (lineCode) {
      output.push(lineCode);
    }
  }

  return output.join("\n");
}

function generateBoxTailwind(
  box: Box,
  allBoxes: Box[],
  options: CodeGeneratorOptions,
  depth: number
): string {
  const { indent, includeComments } = options;
  const indentStr = indent!.repeat(depth);

  const classes = getBoxTailwindClasses(box, allBoxes);
  const hasText = box.text.value.trim() !== "";

  const children = allBoxes
    .filter((b) => b.parentId === box.id)
    .sort((a, b) => a.zIndex - b.zIndex);

  const lines: string[] = [];

  if (includeComments && box.name) {
    lines.push(`${indentStr}<!-- ${box.name} -->`);
  }

  lines.push(`${indentStr}<div class="${classes.join(" ")}">`);

  if (hasText) {
    const formattedText = formatTextWithSemanticTags(
      box.text.value,
      box.text.formatting || []
    );
    const textLines = formattedText.split("\n");
    textLines.forEach((line) => {
      if (line.trim()) {
        lines.push(`${indentStr}${indent}${line}`);
      }
    });
  }

  children.forEach((child) => {
    lines.push(generateBoxTailwind(child, allBoxes, options, depth + 1));
  });

  lines.push(`${indentStr}</div>`);

  return lines.join("\n");
}

function getBoxTailwindClasses(box: Box, allBoxes: Box[]): string[] {
  const classes: string[] = [];
  const hasLayout = box.layout && box.layout.type !== "none";
  const parent = box.parentId
    ? allBoxes.find((b) => b.id === box.parentId)
    : undefined;
  const parentHasLayout = parent?.layout && parent.layout.type !== "none";

  if (hasLayout && box.layout) {
    if (box.layout.type === "flex") {
      classes.push("flex");
      classes.push(
        TAILWIND_MAPPINGS.flexDirection[box.layout.direction] || "flex-row"
      );

      const gapClass = `gap-${getClosestTailwindSpacing(box.layout.gap)}`;
      classes.push(gapClass);

      if (box.layout.justifyContent !== "start") {
        classes.push(
          TAILWIND_MAPPINGS.justifyContent[box.layout.justifyContent] ||
            "justify-start"
        );
      }

      if (box.layout.alignItems !== "stretch") {
        classes.push(
          TAILWIND_MAPPINGS.alignItems[box.layout.alignItems] || "items-stretch"
        );
      }

      if (box.layout.wrap) {
        classes.push("flex-wrap");

        if (box.layout.alignContent && box.layout.alignContent !== "start") {
          classes.push(
            TAILWIND_MAPPINGS.alignContent?.[box.layout.alignContent] ||
              `content-${box.layout.alignContent}`
          );
        }
      }
    } else if (box.layout.type === "grid") {
      classes.push("grid");
      classes.push(`grid-cols-${box.layout.columns}`);
      classes.push(`grid-rows-${box.layout.rows}`);

      const gapClass = `gap-${getClosestTailwindSpacing(box.layout.gap)}`;
      classes.push(gapClass);

      if (box.layout.alignItems && box.layout.alignItems !== "stretch") {
        classes.push(
          TAILWIND_MAPPINGS.alignItems[box.layout.alignItems] || "items-stretch"
        );
      }
      if (box.layout.justifyItems && box.layout.justifyItems !== "stretch") {
        classes.push(
          TAILWIND_MAPPINGS.justifyItems?.[box.layout.justifyItems] ||
            `justify-items-${box.layout.justifyItems}`
        );
      }
    }
  }

  classes.push(`w-[${formatPx(box.width)}px]`);
  classes.push(`h-[${formatPx(box.height)}px]`);

  // Flex child properties
  if (parentHasLayout && parent?.layout?.type === "flex") {
    // Use actual flex values when available
    if (box.layoutChildProps?.flexGrow !== undefined) {
      classes.push(`grow-[${box.layoutChildProps.flexGrow}]`);
    } else {
      classes.push("flex-1");
    }

    if (box.layoutChildProps?.flexShrink !== undefined) {
      classes.push(`shrink-[${box.layoutChildProps.flexShrink}]`);
    }

    if (box.layoutChildProps?.flexBasis) {
      classes.push(`basis-[${box.layoutChildProps.flexBasis}]`);
    }

    classes.push("min-w-[100px]");
    classes.push("min-h-[60px]");

    if (box.layoutChildProps?.alignSelf) {
      classes.push(
        TAILWIND_MAPPINGS.alignSelf?.[box.layoutChildProps.alignSelf] ||
          `self-${box.layoutChildProps.alignSelf}`
      );
    }
  }

  // Grid child properties
  if (parentHasLayout && parent?.layout?.type === "grid") {
    if (box.layoutChildProps?.gridColumn) {
      classes.push(`col-[${box.layoutChildProps.gridColumn}]`);
    }
    if (box.layoutChildProps?.gridRow) {
      classes.push(`row-[${box.layoutChildProps.gridRow}]`);
    }
    if (box.layoutChildProps?.alignSelf) {
      classes.push(
        TAILWIND_MAPPINGS.alignSelf?.[box.layoutChildProps.alignSelf] ||
          `self-${box.layoutChildProps.alignSelf}`
      );
    }
  }

  if (box.padding > 0) {
    const paddingClass = `p-${getClosestTailwindSpacing(box.padding)}`;
    classes.push(paddingClass);
  }

  const borderWidth = box.borderStyle === "double" ? 4 : 2;
  classes.push(`border-${borderWidth === 4 ? "4" : "2"}`);
  classes.push("border-black");

  if (box.borderStyle === "dashed") {
    classes.push("border-dashed");
  } else if (box.borderStyle === "double") {
    classes.push("border-double");
  }

  if (box.text.value && box.text.alignment !== "left") {
    classes.push(
      TAILWIND_MAPPINGS.textAlign[box.text.alignment] || "text-left"
    );
  }

  // Add font size support
  if (box.text.fontSize && box.text.fontSize !== "medium") {
    const fontSizeMap: Record<string, string> = {
      small: "text-sm",
      medium: "text-base",
      large: "text-lg",
    };
    classes.push(fontSizeMap[box.text.fontSize]);
  }

  return classes;
}

function getContainerClasses(artboard: Artboard): string {
  return [
    "relative",
    `w-[${formatPx(artboard.width)}px]`,
    `h-[${formatPx(artboard.height)}px]`,
  ].join(" ");
}

/**
 * Formats text with semantic HTML tags based on formatting array
 */
function formatTextWithSemanticTags(
  text: string,
  formatting: TextFormat[]
): string {
  if (!formatting || formatting.length === 0) {
    return escapeHTML(text);
  }

  interface FormatEvent {
    position: number;
    type: "open" | "close";
    format: TextFormat;
  }

  const events: FormatEvent[] = [];

  formatting.forEach((fmt) => {
    events.push({ position: fmt.start, type: "open", format: fmt });
    events.push({ position: fmt.end, type: "close", format: fmt });
  });

  events.sort((a, b) => {
    if (a.position !== b.position) return a.position - b.position;
    if (a.type === "close" && b.type === "open") return -1;
    if (a.type === "open" && b.type === "close") return 1;
    return 0;
  });

  let result = "";
  let lastPosition = 0;
  const openTags: TextFormat[] = [];

  events.forEach((event) => {
    if (event.position > lastPosition) {
      result += escapeHTML(text.slice(lastPosition, event.position));
    }
    lastPosition = event.position;

    if (event.type === "open") {
      result += getOpenTag(event.format);
      openTags.push(event.format);
    } else {
      const tagIndex = openTags.findIndex(
        (t) =>
          t.start === event.format.start &&
          t.end === event.format.end &&
          t.type === event.format.type
      );
      if (tagIndex !== -1) {
        const tagsToReopen = openTags.slice(tagIndex + 1);
        for (let i = openTags.length - 1; i >= tagIndex; i--) {
          result += getCloseTag(openTags[i]);
        }
        openTags.splice(tagIndex, 1);
        tagsToReopen.forEach((t) => {
          result += getOpenTag(t);
        });
      }
    }
  });

  if (lastPosition < text.length) {
    result += escapeHTML(text.slice(lastPosition));
  }

  return result;
}

function getOpenTag(format: TextFormat): string {
  switch (format.type) {
    case "bold":
      return "<strong>";
    case "italic":
      return "<em>";
    case "code":
      return "<code>";
    case "color":
      return `<span style="color: ${format.value || "inherit"}">`;
    default:
      return "";
  }
}

function getCloseTag(format: TextFormat): string {
  switch (format.type) {
    case "bold":
      return "</strong>";
    case "italic":
      return "</em>";
    case "code":
      return "</code>";
    case "color":
      return "</span>";
    default:
      return "";
  }
}

function escapeHTML(str: string): string {
  return str
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;")
    .replace(/"/g, "&quot;")
    .replace(/'/g, "&#039;");
}

function formatPx(value: number): string {
  const rounded = Math.round(value * 100) / 100;
  if (Number.isInteger(rounded)) {
    return `${rounded}`;
  }
  return `${parseFloat(rounded.toFixed(2))}`;
}

export function getBoxClasses(box: Box, allBoxes: Box[]): string {
  return getBoxTailwindClasses(box, allBoxes).join(" ");
}

export function generateResponsiveTailwind(
  boxes: Box[],
  artboards: Artboard[],
  lines: Line[] = []
): string {
  const sorted = [...artboards].sort((a, b) => a.width - b.width);

  if (sorted.length > 0) {
    return generateTailwind(boxes, sorted[0], DEFAULT_CODE_OPTIONS, lines);
  }

  return generateTailwind(boxes, undefined, DEFAULT_CODE_OPTIONS, lines);
}
