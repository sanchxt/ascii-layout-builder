import type { Box } from "@/types/box";
import type { Artboard } from "@/types/artboard";
import type { CodeGeneratorOptions } from "../types/code";
import {
  DEFAULT_CODE_OPTIONS,
  TAILWIND_MAPPINGS,
  getClosestTailwindSpacing,
} from "../types/code";

export function generateTailwind(
  boxes: Box[],
  artboard?: Artboard,
  options: CodeGeneratorOptions = DEFAULT_CODE_OPTIONS
): string {
  const opts = { ...DEFAULT_CODE_OPTIONS, ...options };
  const { indent, includeComments } = opts;

  const relevantBoxes = artboard
    ? boxes.filter((box) => box.artboardId === artboard.id)
    : boxes.filter((box) => !box.artboardId);

  const rootBoxes = relevantBoxes
    .filter((box) => !box.parentId)
    .sort((a, b) => a.zIndex - b.zIndex);

  if (rootBoxes.length === 0) {
    return "";
  }

  const lines: string[] = [];

  if (includeComments) {
    lines.push("<!-- Generated by ASCII Layout Builder with Tailwind CSS -->");
  }

  if (artboard) {
    const containerClasses = getContainerClasses(artboard);
    lines.push(`<div class="${containerClasses}">`);

    rootBoxes.forEach((box) => {
      lines.push(generateBoxTailwind(box, relevantBoxes, opts, 1));
    });

    lines.push(`</div>`);
  } else {
    rootBoxes.forEach((box) => {
      lines.push(generateBoxTailwind(box, relevantBoxes, opts, 0));
    });
  }

  return lines.join("\n");
}

function generateBoxTailwind(
  box: Box,
  allBoxes: Box[],
  options: CodeGeneratorOptions,
  depth: number
): string {
  const { indent, includeComments } = options;
  const indentStr = indent!.repeat(depth);

  const classes = getBoxTailwindClasses(box, allBoxes);
  const hasText = box.text.value.trim() !== "";

  const children = allBoxes
    .filter((b) => b.parentId === box.id)
    .sort((a, b) => a.zIndex - b.zIndex);

  const lines: string[] = [];

  if (includeComments && box.name) {
    lines.push(`${indentStr}<!-- ${box.name} -->`);
  }

  lines.push(`${indentStr}<div class="${classes.join(" ")}">`);

  if (hasText) {
    const textLines = box.text.value.split("\n");
    textLines.forEach((line) => {
      if (line.trim()) {
        lines.push(`${indentStr}${indent}${escapeHTML(line)}`);
      }
    });
  }

  children.forEach((child) => {
    lines.push(generateBoxTailwind(child, allBoxes, options, depth + 1));
  });

  lines.push(`${indentStr}</div>`);

  return lines.join("\n");
}

function getBoxTailwindClasses(box: Box, allBoxes: Box[]): string[] {
  const classes: string[] = [];
  const hasLayout = box.layout && box.layout.type !== "none";
  const parent = box.parentId
    ? allBoxes.find((b) => b.id === box.parentId)
    : undefined;
  const parentHasLayout = parent?.layout && parent.layout.type !== "none";

  if (hasLayout && box.layout) {
    if (box.layout.type === "flex") {
      classes.push("flex");
      classes.push(
        TAILWIND_MAPPINGS.flexDirection[box.layout.direction] || "flex-row"
      );

      const gapClass = `gap-${getClosestTailwindSpacing(box.layout.gap)}`;
      classes.push(gapClass);

      if (box.layout.justifyContent !== "start") {
        classes.push(
          TAILWIND_MAPPINGS.justifyContent[box.layout.justifyContent] ||
            "justify-start"
        );
      }

      if (box.layout.alignItems !== "stretch") {
        classes.push(
          TAILWIND_MAPPINGS.alignItems[box.layout.alignItems] || "items-stretch"
        );
      }

      if (box.layout.wrap) {
        classes.push("flex-wrap");

        if (box.layout.alignContent && box.layout.alignContent !== "start") {
          classes.push(
            TAILWIND_MAPPINGS.alignContent?.[box.layout.alignContent] ||
              `content-${box.layout.alignContent}`
          );
        }
      }
    } else if (box.layout.type === "grid") {
      classes.push("grid");
      classes.push(`grid-cols-${box.layout.columns}`);
      classes.push(`grid-rows-${box.layout.rows}`);

      const gapClass = `gap-${getClosestTailwindSpacing(box.layout.gap)}`;
      classes.push(gapClass);

      if (box.layout.alignItems && box.layout.alignItems !== "stretch") {
        classes.push(
          TAILWIND_MAPPINGS.alignItems[box.layout.alignItems] || "items-stretch"
        );
      }
      if (box.layout.justifyItems && box.layout.justifyItems !== "stretch") {
        classes.push(
          TAILWIND_MAPPINGS.justifyItems?.[box.layout.justifyItems] ||
            `justify-items-${box.layout.justifyItems}`
        );
      }
    }
  }

  classes.push(`w-[${formatPx(box.width)}px]`);
  classes.push(`h-[${formatPx(box.height)}px]`);

  if (parentHasLayout && parent?.layout?.type === "flex") {
    classes.push("flex-1");
    classes.push("min-w-[100px]");
    classes.push("min-h-[60px]");

    if (box.layoutChildProps?.alignSelf) {
      classes.push(
        TAILWIND_MAPPINGS.alignSelf?.[box.layoutChildProps.alignSelf] ||
          `self-${box.layoutChildProps.alignSelf}`
      );
    }
  }

  if (box.padding > 0) {
    const paddingClass = `p-${getClosestTailwindSpacing(box.padding)}`;
    classes.push(paddingClass);
  }

  const borderWidth = box.borderStyle === "double" ? 4 : 2;
  classes.push(`border-${borderWidth === 4 ? "4" : "2"}`);
  classes.push("border-black");

  if (box.borderStyle === "dashed") {
    classes.push("border-dashed");
  } else if (box.borderStyle === "double") {
    classes.push("border-double");
  }

  if (box.text.value && box.text.alignment !== "left") {
    classes.push(
      TAILWIND_MAPPINGS.textAlign[box.text.alignment] || "text-left"
    );
  }

  if (!parentHasLayout && parent) {
    classes.push("absolute");
    classes.push(`left-[${formatPx(box.x)}px]`);
    classes.push(`top-[${formatPx(box.y)}px]`);
  }

  return classes;
}

function getContainerClasses(artboard: Artboard): string {
  return [
    "relative",
    `w-[${formatPx(artboard.width)}px]`,
    `h-[${formatPx(artboard.height)}px]`,
  ].join(" ");
}

function escapeHTML(str: string): string {
  return str
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;")
    .replace(/"/g, "&quot;")
    .replace(/'/g, "&#039;");
}

function formatPx(value: number): string {
  const rounded = Math.round(value * 100) / 100;
  if (Number.isInteger(rounded)) {
    return `${rounded}`;
  }
  return `${parseFloat(rounded.toFixed(2))}`;
}

export function getBoxClasses(box: Box, allBoxes: Box[]): string {
  return getBoxTailwindClasses(box, allBoxes).join(" ");
}

export function generateResponsiveTailwind(
  boxes: Box[],
  artboards: Artboard[]
): string {
  const sorted = [...artboards].sort((a, b) => a.width - b.width);

  if (sorted.length > 0) {
    return generateTailwind(boxes, sorted[0]);
  }

  return generateTailwind(boxes);
}
