import type { Box } from "@/types/box";
import type { Artboard } from "@/types/artboard";
import type { CSSProperties, CodeGeneratorOptions } from "../types/code";
import { DEFAULT_CODE_OPTIONS } from "../types/code";

export function generateCSS(
  boxes: Box[],
  artboard?: Artboard,
  options: CodeGeneratorOptions = DEFAULT_CODE_OPTIONS
): string {
  const opts = { ...DEFAULT_CODE_OPTIONS, ...options };
  const { indent, includeComments, classPrefix, useRem, remBase } = opts;

  const relevantBoxes = artboard
    ? boxes.filter((box) => box.artboardId === artboard.id)
    : boxes.filter((box) => !box.artboardId);

  if (relevantBoxes.length === 0) {
    return "";
  }

  const rules: string[] = [];

  if (includeComments) {
    rules.push("/* Generated by ASCII Layout Builder */");
    if (artboard) {
      rules.push(`/* Artboard: ${artboard.name} */`);
    }
    rules.push("");
  }

  if (artboard) {
    rules.push(".container {");
    rules.push(
      `${indent}width: ${formatUnit(artboard.width, useRem, remBase)};`
    );
    rules.push(
      `${indent}height: ${formatUnit(artboard.height, useRem, remBase)};`
    );
    rules.push(`${indent}position: relative;`);
    rules.push("}");
    rules.push("");
  }

  const rootBoxes = relevantBoxes.filter((box) => !box.parentId);

  const processBox = (box: Box, depth: number = 0) => {
    const className = getBoxClassName(box, classPrefix!);
    const styles = getBoxStyles(box, relevantBoxes, useRem, remBase);

    if (includeComments && box.name) {
      rules.push(`/* ${box.name} */`);
    }

    rules.push(`.${className} {`);

    Object.entries(styles).forEach(([prop, value]) => {
      if (value) {
        const cssProp = camelToKebab(prop);
        rules.push(`${indent}${cssProp}: ${value};`);
      }
    });

    rules.push("}");
    rules.push("");

    const children = relevantBoxes
      .filter((b) => b.parentId === box.id)
      .sort((a, b) => a.zIndex - b.zIndex);

    children.forEach((child) => processBox(child, depth + 1));
  };

  rootBoxes.forEach((box) => processBox(box));

  return rules.join("\n");
}

function getBoxStyles(
  box: Box,
  allBoxes: Box[],
  useRem?: boolean,
  remBase?: number
): CSSProperties {
  const styles: CSSProperties = {};
  const hasLayout = box.layout && box.layout.type !== "none";
  const parent = box.parentId
    ? allBoxes.find((b) => b.id === box.parentId)
    : undefined;
  const parentHasLayout = parent?.layout && parent.layout.type !== "none";

  if (hasLayout && box.layout) {
    if (box.layout.type === "flex") {
      styles.display = "flex";
      styles.flexDirection = box.layout.direction;
      styles.gap = formatUnit(box.layout.gap, useRem, remBase);

      styles.justifyContent = mapFlexJustify(box.layout.justifyContent);
      styles.alignItems = mapFlexAlign(box.layout.alignItems);

      if (box.layout.wrap) {
        styles.flexWrap = "wrap";
        if (box.layout.alignContent) {
          styles.alignContent = mapFlexJustify(box.layout.alignContent);
        }
      }
    } else if (box.layout.type === "grid") {
      styles.display = "grid";
      styles.gridTemplateColumns = `repeat(${box.layout.columns}, 1fr)`;
      styles.gridTemplateRows = `repeat(${box.layout.rows}, 1fr)`;
      styles.gap = formatUnit(box.layout.gap, useRem, remBase);

      if (box.layout.alignItems && box.layout.alignItems !== "stretch") {
        styles.alignItems = mapFlexAlign(box.layout.alignItems);
      }
      if (box.layout.justifyItems && box.layout.justifyItems !== "stretch") {
        styles.justifyItems = mapFlexAlign(box.layout.justifyItems);
      }
    }
  }

  styles.width = formatUnit(box.width, useRem, remBase);
  styles.height = formatUnit(box.height, useRem, remBase);

  if (parentHasLayout && parent?.layout?.type === "flex") {
    styles.flex = "1";
    styles.minWidth = formatUnit(100, useRem, remBase);
    styles.minHeight = formatUnit(60, useRem, remBase);

    if (box.layoutChildProps?.alignSelf) {
      styles.alignSelf = mapFlexAlign(box.layoutChildProps.alignSelf);
    }
  }

  if (box.padding > 0) {
    styles.padding = formatUnit(box.padding, useRem, remBase);
  }

  const borderWidth = box.borderStyle === "double" ? 4 : 2;
  styles.border = `${borderWidth}px ${mapBorderStyle(box.borderStyle)} #000`;

  if (box.text.value && box.text.alignment !== "left") {
    styles.textAlign = box.text.alignment;
  }

  if (!parentHasLayout) {
    styles.position = "absolute";
    styles.left = formatUnit(box.x, useRem, remBase);
    styles.top = formatUnit(box.y, useRem, remBase);
  }

  return styles;
}

function getBoxClassName(box: Box, prefix: string): string {
  if (box.name) {
    return box.name
      .toLowerCase()
      .replace(/[^a-z0-9]+/g, "-")
      .replace(/^-|-$/g, "");
  }
  const shortId = box.id.split("-")[0];
  return `${prefix}-${shortId}`;
}

function formatUnit(value: number, useRem?: boolean, remBase?: number): string {
  const rounded = Math.round(value * 100) / 100;

  if (useRem && remBase) {
    const remValue = rounded / remBase;
    return `${remValue.toFixed(2)}rem`;
  }

  if (Number.isInteger(rounded)) {
    return `${rounded}px`;
  }
  return `${parseFloat(rounded.toFixed(2))}px`;
}

function camelToKebab(str: string): string {
  return str.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
}

function mapBorderStyle(style: Box["borderStyle"]): string {
  switch (style) {
    case "double":
      return "double";
    case "dashed":
      return "dashed";
    case "single":
    default:
      return "solid";
  }
}

function mapFlexJustify(value: string): string {
  const map: Record<string, string> = {
    start: "flex-start",
    end: "flex-end",
    center: "center",
    "space-between": "space-between",
    "space-around": "space-around",
    "space-evenly": "space-evenly",
  };
  return map[value] || value;
}

function mapFlexAlign(value: string): string {
  const map: Record<string, string> = {
    start: "flex-start",
    end: "flex-end",
    center: "center",
    stretch: "stretch",
  };
  return map[value] || value;
}

export function generateMinifiedCSS(boxes: Box[], artboard?: Artboard): string {
  const css = generateCSS(boxes, artboard, {
    ...DEFAULT_CODE_OPTIONS,
    indent: "",
    includeComments: false,
  });

  return css
    .replace(/\n+/g, "")
    .replace(/\s*{\s*/g, "{")
    .replace(/\s*}\s*/g, "}")
    .replace(/\s*:\s*/g, ":")
    .replace(/\s*;\s*/g, ";");
}
